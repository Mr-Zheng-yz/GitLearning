###参考文章:https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000

###下载安装Git
	* 下载网站
		https://git-scm.com/downloads
		网速慢可以使用国内镜像(https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit)
	
	* 安装完成后,在菜单里找到"Git" -> "Git Bash",蹦出一个类似命令行窗口的东西,就说明Git安装成功!
	
	* 安装完成后,还需要最后一步设置,在命令行输入:
	$ git config --global user.name "Your Name"
	$ git config --global user.email "email"
	
###创建版本库
	* 版本库介绍:
		版本库又名仓库,英文名repository,可以简单理解成一个目录,这个目录里面的所有文件都可以被Git管理起来,每个文件的修改、删除、
		Git都能跟踪，以便任何时刻都可以追踪历史,或者在将来某个时刻可以"还原"
		
	* 创建版本库:
		1. 创建一个目录非常简单,首先,选择一个合适的地方,创建一个空目录:
			`
			$ mkdir learngit		(创建一个项目)
			$ cd learngit			(去到项目中)
			$ pwd					(查看目录)
			`
			如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。
	
		2. 通过[git init]命令把这个目录编程Git可以管理的仓库:
			`
			$ git init
			`
			仓库就创建好了,而且告诉你是一个空仓库(empty Git repository),细心的读者可以发现当前目录下又多了一个[.git]的目录,这个目录是
			Git来跟踪管理版本库的,没事不要受到能够修改这个目录里的文件,不然改乱了,就把Git仓库给破坏了.
			
	* 把文件添加到版本库
		1. 在learngit目录下创建一个readme.txt文件
			注意:一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。
	
		再通过两步将readme.txt放到Git仓库:
		2. 用命令[git add]告诉Git,把文件添加到仓库:
			`
			$ git add readme.txt
			`	
			执行上面的命令,没有任何显示,这就对了,Unix的哲学是"没有消息就是好消息",说明添加成功.
		
		3. 用命令[git commit]告诉Git,把文件提交到仓库:
			`
			$ git commit -m "wrote a readme file"
			`
			[-m]后面输入的是本次提交的说明,可以输入任意内容,内容为本次的改动记录.
			
		*4. 用命令[git commit -a -m ""]可以化上面两步为一步.
		
	* 附加:
		一些常用命令:
			一般仓库中的文件可能存在于这三种状态：
			1）Untracked files → 文件未被跟踪；
			2）Changes to be committed → 文件已缓存，这是下次提交的内容；
			3）Changes bu not updated → 文件被修改，但并没有添加到缓存区。
			git commit -m ""  只会提交添加到缓存区的文件（只提交添加的）
			git commit -a -m ""  能提交修改过，但是没有添加到缓存区的文件（修改过的就能提交）
			使用命令：git log  能查看提交历史，后面加上  --pretty=oneline  能使内容单行显示
			使用命令：git status  能让我们时刻掌握仓库当前的状态

###随时掌握工作区的状态:
	* 要随时掌握工作区的状态，使用[git status]命令。

	* 如果git status告诉你有文件被修改过，用[git diff]命令可以查看修改内容。
	
###版本回退
	git版本回退可以回退到最近一个commit.
	
	* 回退到上一个版本:
		1. 使用[git reset --hard HEAD^]命令可以回退到上一个提交的版本.
			`
			$ git reset --hard HEAD^
			`
			此时使用[git log --pretty=oneline]命令查看日志,发现已经回退到了上一个版本,但是最新的版本啦,但是最新的版本消失不见了
	
	* 回退到上一个版本再回到最新版本
		1. 使用[git reset --hard (commit_id)]命令可以回到指定commit_id对应的版本号
			`
			$ git reset --hard fead5d2
			`
			如果命令行窗口未关闭,可以向上查看最新版的commit_id,使用该命令回退,如果忘记了
			
	* 查看历史commit_id
		1. 使用[git reflog]查看命令历史,以便确定要回到未来哪个版本
		
	* 注意工作区和暂存区状态
		1. 用[git diff HEAD -- readme.txt]命令可以查看工作区和版本库修改区别.
			
###撤销修改
	1. 当你改乱了工作区某个文件的内容,想直接丢弃工作区的修改时,用命令[git checkout -- file]
		`
		$ git checkout -- readme.txt
		`		
	
	2. 当你不但改乱了工作区某个文件的内容,还添加到了暂存区时,想要丢弃修改,分两步,第一步用命令[git reset HEAD file],就回到了场景1,第二步,看1
		`
		$ git reset HEAD readme.txt
		`
	
	3. 已经提交了不合适的修改到版本库时,想要撤销本次提交,就是用版本回退,不过前提是没有推送到远程库.
			
###删除文件
	当你用[rm test.txt]删除一个文件时,如果该文件已提交至版本库,一般面临两种情景:
	1. 删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：
		`
		$ git checkout -- test.txt
		`
		[git checkout]其实是用版本库里的版本替换工作区的版本,如论工作区是修改还是删除,都可以"一键还原"
	
	2. 你确实想要删除这个文件:把版本库里的这个文件也删除,更新版本库
		`
		$ git rm test.txt
		
		$ git commit -m "remove test.txt"
		`
		命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。
			
###使用GitHub的远程仓库
	GitHub[https://github.com/],这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。
	
	* 由于本地Git仓库与GitHub仓库之间是通过SSH加密的,所以需要一点设置:
		1. 创建SSH Key.在用户主目录下,看看有没有.ssh目录,如果有,再看看有没有[id_rsa]和[id_rsa.pub]这两个文件,如果已经有了,可以直接进行下一步.如果没有,打开Shell(Windows下打开GitBash)
		创建SSH Key:
			`
			$ ssh-keygen -t rsa -C "youremail@example.com"
			`
			然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。
			如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人.
		
		2. 登陆GitHub，打开“Account settings”，“SSH Keys”页面：
			然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：
			点“Add Key”，你就应该看到已经添加的Key：
			
			为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。
			当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。

	* 添加远程库
		fatal: remote origin already exists.[http://blog.csdn.net/dengjianqiang2011/article/details/9260435]
		创建GitHub远程仓库[https://www.cnblogs.com/zhouxihi/p/6181737.html]
		"ssh: connect to host github.com port 22: Connection timed out"[http://blog.csdn.net/vosang/article/details/50499300]
	
		1. 要关联一个远程库,使用命令[git remote add origin git@server -name:path/repo-name.git]
			`
			$ git remote add origin git@github.com:Mr-Zheng-yz/learngit.git
			`
		2. 关联后,使用命令[git push -u origin master]第一次推送master分支的所有内容;
			此后,每次本地提交后,只要有必要,就可以使用命令[git push origin master]推送最新修改;
			
			(分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就
			完成了同步，真是太方便了！)
			
	* 从远程库克隆
		如果从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。
		
		1. 在GitHub创建新仓库
			在GitHub上创建一个新的仓库,勾选{Initialize this repository with a README},这样GitHub会自动为我们创建一个README.md文件。
			
		2. 克隆GitHub创建的仓库到本地
			`
			$ git clone git@github.com:michaelliao/gitskills.git
			$ cd gitskills
			$ ls
			`
			
			Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。
			https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令
			
###分支管理
	分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写
	完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。

	有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想
	提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。
	
	* 创建分支与合并:
		1. 创建一个dev分支
			当我们创建新的分支，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：
			不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变:
			* 使用命令[git checkout -b dev]创建并切换dev分支
			`
			$ git checkout -b dev
			`
			[git checkout]命令加上-b参数表示创建并切换，相当于以下两条命令：
			`
			$ git branch dev
			$ git checkout dev
			`
			
		2. 在dev分支上提交修改
			命令[git commit -a -m ""]提交修改,此时切换回master分支发现刚刚提交的修改不见了!因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：
		
		3. 切换到master分支
			用命令[git checkout master]切换回master分支
			`
			$ git checkout master
			`
		
		4. 将dev分支修改内容合并到master上
			就是直接把master指向dev的当前提交，就完成了合并：
			用命令[git merge dev]:
			`
			$ git merge dev
			`
			[git merge]命令用于合并指定分支.合并后,再查看修改,和dev分支的最新提交时完全一样的.
		
		5. 删除dev分支
			合并完成后,就可以删除dev分支了;删除dev分支就是把dev指针给删掉;
			用命令[git branch -d dev]:
			`
			$ git branch -d dev
			`
			由于git创建分支速度快,并且功能强大,Git鼓励大量使用分支;
			
	* 冲突解决与日志查询
		1. 分支合并后发生冲突
			当其他分支与当前分支合并时发生冲突后,命令[git status]可以定位发生冲突文件,打开发生冲突的文件后,
			Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，修改后保存:
			`
			$ git commit -a -m "冲突解决"
			`
			此时其他分支与当前分支完成合并;
			
		2. 用git log --graph命令可以看到分支合并图。
			用带参数的git log也可以看到分支的合并情况：
			`
			$ git log --graph --pretty=oneline --abbrev-commit
			`

	* 分支管理策略
		1. 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
		如果要强制禁用Fast forward模式,Git就会在merge时生成一个新的commit,这样,从分支历史上就可以看出分支信息.
		
		2. 用命令[git merge --no-ff -m "描述" dev]来合并分支
			`
			$ git merge --no-ff -m "merge with no-ff" dev
			`
			--no-ff表示禁用Fast forward模式;
			
		合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来
		曾经做过合并。
			
	* Bug分支
		有了bug就要修复,在Git中,由于分支是如此的强大,所以,每个bug都可以通过一个新的临时分支来修复,修复后,合并分支,然后将临时分支删除.
	
		1. 保存工作现场
			场景:当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在
			dev上进行的工作还没有提交.Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：
			
			用命令[git stash]命令保存工作;
			`
			$ git stash
			`
			现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。
		
		2. 创建分支解决bug,解决后删除临时分支
			...
		
		3. 查看分支上所保存的工作保存列表
			切换到保存工作现场的分支,使用命令[git stash list]命令来查看保存的工作;
			`
			$ git stash
			`
		
		4. 恢复工作现场
			* 
				- 恢复后stash内容不删除,用[git stash apply]命令,恢复后stash内容并不删除,这时需要[git stash drop]命令删除;
					`
					$ git stash apply
					$ git stash drop
					`
				- 恢复的同时,把stash内容也删了,用命令[git stash pop]
					`
					$ git stash pop
					`
			
		
		5. 恢复指定的工作现场
			可以多次stash,回复的时候,先用[git stash list]查看,然后回复指定的stash,用命令[git stash apply stash@{0}]
			`
			$ git stash apply stash@{0}
			`
		
		修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；
		当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			